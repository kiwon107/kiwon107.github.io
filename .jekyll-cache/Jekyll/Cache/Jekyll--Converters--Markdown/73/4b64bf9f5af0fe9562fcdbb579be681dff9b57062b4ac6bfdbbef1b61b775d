I"<p>본 포스팅은 “펭귄브로의 3분 딥러닝, 파이토치맛” 책 내용을 기반으로 작성되었습니다.
잘못된 내용이 있을 경우 지적해 주시면 감사드리겠습니다.</p>

<h2 id="2-1-오염된-이미지-문제와-복원-방법">2-1. 오염된 이미지 문제와 복원 방법</h2>
<p>오염된 이미지와 이미지 처리 함수 <code class="language-plaintext highlighter-rouge">weird_function()</code>을 이용하여 원본 이미지를 복원하는 문제이다.</p>

<p>다음과 같은 사고 과정을 거쳐보자!</p>
<ol>
  <li>오염된 이미지와 같은 크기의 랜덤 텐서 생성</li>
  <li>랜덤 텐서를 <code class="language-plaintext highlighter-rouge">weird_function()</code> 함수에 입력하여 똑같이 오염된 이미지 생성. 이때 인위적으로 생성한 복사본 이미지를 가설이라고 함!</li>
  <li>가설과 오염된 이미지가 같다면, 무작위 이미지와 원본 이미지도 같을 것!</li>
  <li>이에따라, <code class="language-plaintext highlighter-rouge">weird_function(random_tensor) = broken_image</code> 관계 성립되도록 만듬.</li>
</ol>

<p>위 사고 과정을 실체화에 성공한다면, random_tensor는 원본이미지와 거의 비슷한 형태가 될 것이다.<br /></p>

<p>이를 구현하기 위해, 우리는 가설인 random_tensor와 원본 이미지(<code class="language-plaintext highlighter-rouge">weird_function()</code> 들어가기 전) 사이의 거리 값을 오차로 두어, 이 오차값이 최솟값이 되도록 랜덤 텐서를 바꿔주어야 한다. 랜덤 텐서를 바꿔주는 것은 경사하강법 알고리즘을 사용한다.  <code class="language-plaintext highlighter-rouge">Autograd</code> 패키지를 이용하여 오차를 출력하는 함수의 기울기를 구하고, 이 기울기의 반대 방향으로 가면 오차값이 줄어든다. 이것을 계속 반복하여, 오차값이 최소가 되었을 때의 <code class="language-plaintext highlighter-rouge">random_tensor</code>값을 보면 원본 이미지와 거의 비슷한 형태가 될 것이다.</p>

<h2 id="2-2-문제-해결과-코드-구현">2-2. 문제 해결과 코드 구현</h2>
<p>파이토치, 맷플롯립을 임포트 한다. 오염된 이미지 파일 로딩하는데 사용할 피클 라이브러리도 임포트 한다. 피클은 파이썬 객체를 파이썬 형태로 저장할 때 쓰는 패키지로, 파이썬에서 기본적으로 제공한다. 오염된 이미지를 파이썬 텐서의 형태로 읽고 이들을 시각화해보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">broken_image</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">FloatTensor</span><span class="p">(</span> <span class="n">pickle</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">'./broken_image_t_p'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">),</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'latin1'</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">broken_image</span><span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
</code></pre></div></div>
<p class="align-center"><img src="/assets/images/deeplearningpyt/2-1.png" alt="그림 2-1. 코드 결과" /></p>
<p>그림 2-1. 코드 결과</p>

<p><code class="language-plaintext highlighter-rouge">broken_image</code>는 이미지 행렬을 랭크 1의 벡터로 표현한 텐서 데이터이다. 10,000개의 원소를 [100, 100] 모양의 행렬이 되도록 변환시켜 이를 시각화 하였다.</p>

<p>이제 <code class="language-plaintext highlighter-rouge">weird_function</code> 함수를 만들자</p>

<p>```python
def weird_function(x, n_iter=5):
    h = x
    filt = torch.tensor([-1./3, 1./3, -1./3]) # 필터! 무슨 필터인지는 아직 모르겠다.
    for i in range(n_iter):
        zero_tensor = torch.tensor([1.0*0])
        h_l = torch.cat((zero_tensor, h[:-1]), 0)  # zero_tensor와 h[:-1]을 concatenate 한다
        h_r = torch.cat((h[1:], zero_tensor), 0)   # h[:-1]와 zero_tensor를 concatenate 한다
        h = filt[0] * h + filt[2] * h_l + filt[1] * h_r
        if i % 2 == 0:
            h = torch.cat((h[h.shape[0]//2:], h[:h.shape[0]//2]), 0)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return h
</code></pre></div></div>
:ET